<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>æ·±å¤§æ™ºèƒ½å¯¼èˆª - å…¨åŠ¨æ€è§†è§‰ç‰ˆ</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root { --accent: #800000; --bg: #f4f4f7; --text: #333; --panel: rgba(255,255,255,0.98); }
        .dark-mode { --bg: #0a0a0c; --text: #e0e0e0; --panel: rgba(30,30,35,0.98); }
        
        body { margin: 0; background: var(--bg); color: var(--text); font-family: -apple-system, sans-serif; overflow: hidden; transition: 0.3s; }
        #map { height: 100vh; width: 100vw; transition: height 0.4s ease; background: #ddd; }
        .dark-mode #map { background: #050508; }
        
        #map.shrink { height: 60vh; }
        #map.mini-shrink { height: 92vh; }

        .brand-header {
            position: absolute; top: 0; left: 0; width: 100%; height: 50px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.95), rgba(255,255,255,0.7));
            backdrop-filter: blur(10px); z-index: 2005;
            display: flex; align-items: center; justify-content: center;
            border-bottom: 1px solid rgba(128,0,0,0.1);
        }
        .dark-mode .brand-header {
            background: linear-gradient(to bottom, rgba(15,15,20,0.95), rgba(15,15,20,0.7));
            border-bottom-color: rgba(255,255,255,0.05);
        }
        .brand-title {
            color: var(--accent); font-size: 18px; font-weight: 800; letter-spacing: 2px;
            display: flex; align-items: center; gap: 8px;
        }

        .top-ui { position: absolute; top: 60px; width: 92%; left: 4%; z-index: 2000; display: flex; flex-direction: column; gap: 10px; }
        .search-row { display: flex; gap: 8px; }
        .input-group { flex: 1; display: flex; background: #fff; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); overflow: hidden; height: 46px; }
        .dark-mode .input-group { background: #2a2a2e; border: 1px solid #3a3a40; }
        #destInput { flex: 1; padding: 0 16px; border: none; font-size: 16px; outline: none; background: transparent; color: inherit; }
        
        .side-controls { display: flex; flex-direction: column; gap: 8px; }
        .icon-btn { width: 46px; height: 46px; border-radius: 12px; border: none; background: #fff; cursor: pointer; font-size: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); display: flex; align-items: center; justify-content: center; transition: 0.2s; }
        .dark-mode .icon-btn { background: #2a2a2e; color: #fff; border: 1px solid #3a3a40; }

        .bottom-nav { position: fixed; bottom: 0; width: 100%; height: 40vh; background: var(--panel); transform: translateY(100%); transition: all 0.4s ease; z-index: 2001; border-radius: 20px 20px 0 0; box-shadow: 0 -5px 25px rgba(0,0,0,0.2); }
        .bottom-nav.show { transform: translateY(0); }
        .bottom-nav.collapsed { height: 65px; transform: translateY(0); }

        .nav-header { display: flex; align-items: center; border-bottom: 1px solid rgba(128,128,128,0.2); padding-right: 15px; }
        .route-tabs { flex: 1; display: flex; overflow-x: auto; scrollbar-width: none; }
        .tab { flex: 1; padding: 20px 10px; text-align: center; cursor: pointer; font-weight: bold; font-size: 14px; opacity: 0.4; white-space: nowrap; }
        .tab.active { opacity: 1; color: var(--accent); border-bottom: 3px solid var(--accent); }

        .fold-btn { background: var(--accent); border: none; font-size: 11px; cursor: pointer; padding: 6px 14px; border-radius: 20px; color: #fff; font-weight: bold; }
        .route-detail { padding: 20px; overflow-y: auto; height: calc(40vh - 65px); }
        
        #status-bar { position: absolute; top: 115px; left: 5%; z-index: 1500; font-size: 12px; background: rgba(0,0,0,0.85); color: white; padding: 6px 12px; border-radius: 6px; pointer-events: none; border: 1px solid rgba(255,255,255,0.1); transition: 0.3s; }
        
        .poi-label { background: transparent !important; border: none !important; box-shadow: none !important; font-weight: bold; color: var(--accent); text-shadow: 1px 1px 2px white, -1px -1px 2px white, 0 0 5px white; font-size: 13px; pointer-events: none; }
        .dark-mode .poi-label { color: #ffbaba; text-shadow: 1px 1px 2px black, -1px -1px 2px black, 0 0 5px black; }
        .poi-popup-btn { background: var(--accent); color: white; border: none; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: bold; margin-top: 8px; width: 100%; font-size: 14px; }
    </style>
</head>
<body>

<div class="brand-header">
    <div class="brand-title">æ·±åœ³å¤§å­¦äººè¡Œå¯¼èˆª</div>
</div>

<div class="top-ui">
    <div class="search-row">
        <div class="input-group">
            <input type="text" id="destInput" list="pointsList" placeholder="è¦å»å“ªé‡Œï¼Ÿ" onkeydown="if(event.key==='Enter')triggerNav()">
            <button class="icon-btn" style="box-shadow:none; width:50px; color:var(--accent);" onclick="triggerNav()">ğŸš€</button>
        </div>
        <datalist id="pointsList"></datalist>
        <div class="side-controls">
            <button class="icon-btn" onclick="getLocation()" title="è·å–å½“å‰ä½ç½®">ğŸ›°ï¸</button>
            <button class="icon-btn" onclick="toggleTheme()" id="themeBtn">â˜€ï¸</button>
            <button class="icon-btn" onclick="resetMap()" title="æ¸…é™¤å¹¶è§£é”èµ·ç‚¹">ğŸ”„</button>
        </div>
    </div>
</div>

<div id="status-bar">å°±ç»ªï¼šç‚¹å‡» POI æˆ–æŒ‰é’®è®¾ç½®èµ·ç‚¹</div>
<div id="map"></div>

<div class="bottom-nav" id="bottomNav">
    <div class="nav-header">
        <div class="route-tabs" id="tabContainer"></div>
        <button class="fold-btn" onclick="toggleFold()" id="foldBtn">æ”¶èµ·</button>
    </div>
    <div class="route-detail">
        <div id="routeTag" style="font-size:12px; color:var(--accent); font-weight:bold; margin-bottom:4px;">æœ€ä½³æ–¹æ¡ˆ</div>
        <h3 id="targetTitle" style="margin:0 0 10px 0;">ç›®çš„åœ°</h3>
        <div id="routeDesc" style="line-height: 1.6; font-size: 15px;"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// --- ç²¾ç¡®è·ç¦»ç®—æ³• ---
function getHaversineDistance(coords1, coords2) {
    const R = 6371e3;
    const Ï†1 = coords1[1] * Math.PI / 180;
    const Ï†2 = coords2[1] * Math.PI / 180;
    const Î”Ï† = (coords2[1] - coords1[1]) * Math.PI / 180;
    const Î”Î» = (coords2[0] - coords1[0]) * Math.PI / 180;
    const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) + Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

class PathEngine {
    constructor(geojson) {
        this.graph = new Map();
        geojson.features.forEach(f => {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
                this.addEdge(coords[i], coords[i+1], f.properties);
            }
        });
    }
    addEdge(c1, c2, p) {
        const p1 = c1.join(','), p2 = c2.join(',');
        if (!this.graph.has(p1)) this.graph.set(p1, []);
        if (!this.graph.has(p2)) this.graph.set(p2, []);
        const dist = getHaversineDistance(c1, c2);
        const edge = { to: p2, l: dist, w: p.Width||3, e: p.Environment||3, s: p.Safety||3, penalty: 0 };
        this.graph.get(p1).push(edge);
        this.graph.get(p2).push({...edge, to: p1});
    }
    resetPenalties() { this.graph.forEach(edges => edges.forEach(e => e.penalty = 0)); }
    findPath(startPt, endPt, weightFn) {
        const findN = (pt) => {
            let n = null, min = Infinity;
            for (let k of this.graph.keys()) {
                const c = k.split(',').map(Number);
                const d = Math.pow(c[0]-pt[0],2)+Math.pow(c[1]-pt[1],2);
                if(d < min) { min = d; n = k; }
            }
            return n;
        };
        const s = findN(startPt), t = findN(endPt);
        if (!s || !t) return null;
        let dists = {}, prev = {}, pq = [{n: s, d: 0}];
        for (let k of this.graph.keys()) dists[k] = Infinity;
        dists[s] = 0;
        while (pq.length > 0) {
            pq.sort((a,b) => a.d - b.d);
            const {n:u} = pq.shift();
            if (u === t) break;
            if(!this.graph.get(u)) continue;
            for (let e of this.graph.get(u)) {
                let cost = weightFn(e) + e.penalty;
                if (dists[u] + cost < dists[e.to]) {
                    dists[e.to] = dists[u] + cost;
                    prev[e.to] = u;
                    pq.push({n: e.to, d: dists[e.to]});
                }
            }
        }
        const path = []; let d = 0, edgesUsed = [];
        for (let c = t; c && prev[c]; c = prev[c]) {
            path.push(c.split(',').map(Number));
            const edge = this.graph.get(c).find(e => e.to === prev[c]);
            if(edge) { d += edge.l; edgesUsed.push(edge); }
        }
        path.push(s.split(',').map(Number));
        return { coords: path.reverse(), distance: d, edgesUsed };
    }
}

const DescriptionLib = {
    get(label, isDark) {
        const p = isDark ? {
            "æ›´å®‰å…¨": ["æ²¿é€”è·¯ç¯æ˜äº®ï¼Œå¤œé—´è¡Œèµ°é¦–é€‰ã€‚", "ä¸»è·¯å®½é˜”ï¼Œè§†é‡æ— æ­»è§’ã€‚"],
            "æ›´çŸ­": ["å½’å®¿æœ€å¿«è·¯å¾„ï¼Œç‰©ç†è·ç¦»æœ€çŸ­ã€‚", "èŠ‚çœä½“åŠ›çš„æœ€é«˜æ•ˆè·¯çº¿ã€‚"],
            "ç¯å¢ƒæ›´å¥½": ["æ™šé£ä¹ ä¹ ï¼Œäº«å—é™è°§æ ¡å›­å¤œæ™¯ã€‚"]
        } : {
            "æ›´èˆ’é€‚": ["æ¤è¢«ç¹èŒ‚ï¼Œæ ‘è«é®è”½ï¼Œåˆåæ­¥è¡Œé¦–é€‰ã€‚", "æ™¯è§‚è·¯æ®µæ¯”ä¾‹é«˜ï¼Œé€‚åˆæ…¢æ­¥ã€‚"],
            "æ›´çŸ­": ["ç‰©ç†è·ç¦»æœ€çŸ­ï¼Œèµ¶è¯¾å¿…å¤‡ã€‚", "ç›´è¾¾ç›®çš„åœ°ï¼Œä¸ç»•å†¤æ‰è·¯ã€‚"],
            "æ›´å®‰å…¨": ["ä¸»è¦é“è·¯é€šè¡Œï¼Œè·¯é¢å¹³å¦ã€‚"]
        };
        return (p[label] || ["æ™ºèƒ½æ¨èè·¯çº¿"])[Math.floor(Math.random() * (p[label]?.length || 1))];
    }
};

const map = L.map('map', { zoomControl: false, attributionControl: false }).setView([22.532, 113.936], 17);
let engine, pointsData, userLocation, isDark = false, routes = [], activePolyline = null, layers = {};
let pointsLayer, uM = null, isLocked = false;

// --- å®šä½åŠŸèƒ½å‡½æ•° ---
function getLocation() {
    const status = document.getElementById('status-bar');
    if (!navigator.geolocation) {
        alert("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå®šä½åŠŸèƒ½");
        return;
    }
    status.innerText = "ğŸ›°ï¸ æ­£åœ¨é‡‡é›†æ‰‹æœºä½ç½®...";
    status.style.background = "#800000";

    navigator.geolocation.getCurrentPosition(
        (position) => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            // è®¾ç½®ä¸ºèµ·ç‚¹
            setAsStart([lng, lat]);
            map.flyTo([lat, lng], 18);
            status.innerText = "ğŸ“ å·²æˆåŠŸå®šä½å½“å‰ä½ç½®";
            status.style.background = "rgba(0,100,0,0.85)";
            setTimeout(() => { 
                status.style.background = "rgba(0,0,0,0.85)";
            }, 3000);
        },
        (error) => {
            status.innerText = "âŒ å®šä½å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨è®¾ç½®";
            status.style.background = "#555";
            alert("æ— æ³•è·å–ä½ç½®ï¼Œè¯·æ£€æŸ¥æ˜¯å¦å¼€å¯ GPS æˆ–æˆæƒå®šä½æƒé™ã€‚");
        },
        { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
    );
}

async function init() {
    try {
        const [g, w, b, r, p] = await Promise.all([
            fetch('green.json').then(r => r.json()), fetch('water.json').then(r => r.json()),
            fetch('buildings.json').then(r => r.json()), fetch('roads.json').then(r => r.json()),
            fetch('points.json').then(r => r.json())
        ]);
        
        layers.green = L.geoJSON(g).addTo(map);
        layers.water = L.geoJSON(w).addTo(map);
        layers.buildings = L.geoJSON(b).addTo(map);
        layers.roads = L.geoJSON(r).addTo(map);
        engine = new PathEngine(r);
        pointsData = p;

        pointsLayer = L.geoJSON(p, {
            pointToLayer: (f, l) => L.circleMarker(l, getPointStyle(map.getZoom())),
            onEachFeature: (f, l) => {
                const n = f.properties.name, coords = f.geometry.coordinates;
                l.bindTooltip(n, { permanent: true, direction: 'right', className: 'poi-label', offset: [12, 0] });
                document.getElementById('pointsList').appendChild(new Option(n, n));
                l.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    let pop = `<div style="text-align:center"><b>${n}</b><br>`;
                    if (!isLocked) pop += `<button class="poi-popup-btn" onclick="setAsStart([${coords[0]}, ${coords[1]}])">è®¾ä¸ºèµ·ç‚¹</button>`;
                    pop += `<button class="poi-popup-btn" style="background:#444" onclick="startNav('${n}')">è®¾ä¸ºç›®çš„åœ°</button></div>`;
                    l.bindPopup(pop).openPopup();
                });
                if(map.getZoom() < 17) l.closeTooltip();
            }
        }).addTo(map);
        updateThemeStyles();
    } catch (e) { console.error("æ•°æ®åŠ è½½å¤±è´¥", e); }
}

function getPointStyle(zoom) {
    let radius = zoom >= 18 ? 6 : (zoom === 17 ? 4.5 : (zoom === 16 ? 3 : 1.5));
    return { radius, fillColor: "#800000", color: "#fff", weight: zoom > 16 ? 2 : 1, fillOpacity: 1 };
}

map.on('zoomend', () => {
    const z = map.getZoom();
    pointsLayer.eachLayer(l => {
        l.setStyle(getPointStyle(z));
        z >= 17 ? l.openTooltip() : l.closeTooltip();
    });
    if (layers.roads) layers.roads.eachLayer(l => {
        const bw = l.feature.properties.Width || 3;
        const sf = z <= 14 ? 0.4 : (z === 15 ? 0.6 : (z === 16 ? 1 : (z === 17 ? 1.5 : 2.2)));
        l.setStyle({ weight: bw * sf });
    });
});

function setAsStart(coords) {
    userLocation = coords;
    const latlng = L.latLng(coords[1], coords[0]);
    if (!uM) uM = L.circleMarker(latlng, { radius: 10, fillColor: '#007AFF', color: '#fff', weight: 3, fillOpacity: 1, zIndexOffset: 2000 }).addTo(map);
    else uM.setLatLng(latlng);
    uM.bringToFront();
    isLocked = true;
    map.closePopup();
    document.getElementById('status-bar').innerText = "ğŸ“ èµ·ç‚¹å·²å›ºå®šï¼Œæœç´¢ç›®çš„åœ°å³å¯";
}

map.on('click', e => { if (!isLocked) setAsStart([e.latlng.lng, e.latlng.lat]); });

function resetMap() {
    isLocked = false; userLocation = null;
    if (uM) { map.removeLayer(uM); uM = null; }
    if (activePolyline) { map.removeLayer(activePolyline); activePolyline = null; }
    document.getElementById('destInput').value = "";
    document.getElementById('bottomNav').classList.remove('show');
    document.getElementById('map').className = "";
    updatePointStyles();
    document.getElementById('status-bar').innerText = "âœ¨ å·²è§£é”ï¼Œå¯é‡æ–°è®¾ç½®èµ·ç‚¹";
}

function triggerNav() {
    const v = document.getElementById('destInput').value;
    if (pointsData.features.some(f => f.properties.name === v)) startNav(v);
    else alert("æœªæ‰¾åˆ°è¯¥åœ°ç‚¹");
}

function startNav(name) {
    if (!userLocation) return alert("è¯·å…ˆè®¾ç½®èµ·ç‚¹");
    const target = pointsData.features.find(f => f.properties.name === name);
    const dest = target.geometry.coordinates;
    map.closePopup();
    engine.resetPenalties();
    routes = [];
    const configs = isDark ? 
        [{l:"æ›´çŸ­", w:e=>e.l}, {l:"æ›´å®‰å…¨", w:e=>e.l*0.2+(10-e.s)*0.8}, {l:"ç¯å¢ƒæ›´å¥½", w:e=>e.l*0.3+(10-e.e)*0.7}] :
        [{l:"æ›´çŸ­", w:e=>e.l}, {l:"æ›´èˆ’é€‚", w:e=>e.l*0.2+(10-e.e)*0.8}, {l:"æ›´å®‰å…¨", w:e=>e.l*0.4+(10-e.s)*0.6}];

    configs.forEach((cfg, idx) => {
        let res = engine.findPath(userLocation, dest, cfg.w);
        if (res) {
            if (idx === 0) res.edgesUsed.forEach(e => e.penalty += 200);
            routes.push({ label: cfg.l, path: res.coords, dist: res.distance });
        }
    });
    updatePointStyles(name);
    renderUI(name);
}

function renderUI(name) {
    const tc = document.getElementById('tabContainer'); tc.innerHTML = "";
    routes.forEach((r, i) => {
        const d = document.createElement('div');
        d.className = `tab ${i===0?'active':''}`; d.innerText = r.label;
        d.onclick = () => switchRoute(i); tc.appendChild(d);
    });
    document.getElementById('targetTitle').innerText = name;
    document.getElementById('bottomNav').classList.add('show');
    document.getElementById('map').className = "shrink";
    switchRoute(0);
}

function switchRoute(idx) {
    if (activePolyline) map.removeLayer(activePolyline);
    const r = routes[idx];
    activePolyline = L.polyline(r.path.map(p => [p[1], p[0]]), { color: idx===0?(isDark?'#ff4d4d':'#800000'):'#666', weight: 8, opacity: 0.9, lineCap: 'round' }).addTo(map);
    document.querySelectorAll('.tab').forEach((t, i) => t.className = i===idx ? 'tab active' : 'tab');
    const m = Math.round(r.dist);
    document.getElementById('routeTag').innerText = idx === 0 ? "æœ€ä½³æ–¹æ¡ˆ" : "å¤‡é€‰æ–¹æ¡ˆ " + idx;
    document.getElementById('routeDesc').innerHTML = `å…¨ç¨‹ <b>${m}</b> ç±³ | é¢„è®¡æ­¥è¡Œ <b>${Math.ceil(m/75)}</b> åˆ†é’Ÿ<br>ğŸ’¡ ${DescriptionLib.get(r.label, isDark)}`;
    map.fitBounds(activePolyline.getBounds(), { padding: [40, 40] });
    if(uM) uM.bringToFront();
}

function updatePointStyles(targetName = null) {
    pointsLayer.eachLayer(layer => {
        const isTarget = layer.feature.properties.name === targetName;
        layer.setStyle({ opacity: targetName?(isTarget?1:0.05):1, fillOpacity: targetName?(isTarget?1:0.05):1 });
        if(isTarget) layer.openTooltip();
    });
}

function toggleTheme() {
    isDark = !isDark;
    document.body.classList.toggle('dark-mode', isDark);
    document.getElementById('themeBtn').innerText = isDark ? "ğŸŒ™" : "â˜€ï¸";
    updateThemeStyles();
}

function updateThemeStyles() {
    const s = isDark ? {
        green: { fillColor: "#0f1a11", color: "#1b3320", weight: 1, fillOpacity: 0.8 },
        water: { fillColor: "#08121c", color: "#1a3d5f", weight: 1, fillOpacity: 0.9 },
        buildings: { fillColor: "#3a3a45", color: "#8a8a9a", weight: 2.5, fillOpacity: 0.95 }
    } : {
        green: { fillColor: "#b8d8ba", color: "#7ba37d", weight: 1, fillOpacity: 0.7 },
        water: { fillColor: "#a2d2ff", color: "#5fa8d3", weight: 1, fillOpacity: 0.8 },
        buildings: { fillColor: "#e8e8e8", color: "#777777", weight: 2.5, fillOpacity: 0.8 }
    };
    Object.keys(s).forEach(k => { if(layers[k]) layers[k].setStyle(s[k]); });
}

function toggleFold() {
    const isC = document.getElementById('bottomNav').classList.toggle('collapsed');
    document.getElementById('map').className = isC ? "mini-shrink" : "shrink";
    document.getElementById('foldBtn').innerText = isC ? "å±•å¼€" : "æ”¶èµ·";
    setTimeout(() => map.invalidateSize(), 400);
}

init();
</script>
</body>
</html>
