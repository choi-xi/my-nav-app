<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>æ·±å¤§æ™ºèƒ½å¯¼èˆª - ç®—æ³•å†…ç½®ç‰ˆ</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root { --bg: #f8f9fa; --accent: #800000; --blue: #007AFF; --panel: rgba(255,255,255,0.95); }
        body { margin: 0; background: var(--bg); font-family: -apple-system, sans-serif; overflow: hidden; }
        #map { height: 100vh; width: 100vw; transition: height 0.4s ease; background: #e0e0e0; }
        #map.shrink { height: 65vh; }
        .top-bar { position: absolute; top: 15px; width: 92%; left: 4%; z-index: 1000; display: flex; gap: 8px; }
        #destInput { flex: 1; padding: 12px 16px; border-radius: 12px; border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.1); background: #fff; font-size: 16px; outline: none; }
        .action-btn { background: var(--blue); color: white; border: none; padding: 0 20px; border-radius: 12px; font-weight: bold; cursor: pointer; }
        .bottom-nav { position: fixed; bottom: 0; width: 100%; height: 35vh; background: #fff; transform: translateY(100%); transition: transform 0.4s; z-index: 1001; box-shadow: 0 -5px 20px rgba(0,0,0,0.1); }
        .bottom-nav.show { transform: translateY(0); }
        .nav-content { padding: 20px; border-top: 5px solid var(--accent); }
        #status-bar { position: absolute; top: 75px; left: 5%; z-index: 1000; font-size: 11px; background: rgba(0,0,0,0.7); padding: 4px 12px; border-radius: 4px; color: #fff; }
    </style>
</head>
<body>

<div class="top-bar">
    <input type="text" id="destInput" list="pointsList" placeholder="è¾“å…¥ç›®çš„åœ° (å¦‚: æ±‡æ™ºæ¥¼)...">
    <datalist id="pointsList"></datalist>
    <button class="action-btn" onclick="triggerNav()">å¯¼èˆª</button>
</div>
<div id="status-bar">æ­£åœ¨åŠ è½½æ ¡åŒºæ•°æ®...</div>
<div id="map"></div>

<div class="bottom-nav" id="bottomNav">
    <div class="nav-content">
        <h3 id="targetName" style="margin:0 0 10px 0; color:var(--accent);">ç›®çš„åœ°</h3>
        <p id="routeInfo" style="margin:0; font-size:15px; color:#444;">è®¡ç®—ä¸­...</p>
        <button onclick="location.reload()" style="margin-top:20px; width:100%; padding:12px; border:none; background:#eee; border-radius:8px; font-weight:bold; cursor:pointer;">é‡ç½®åœ°å›¾</button>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/** * ç²¾ç®€ç‰ˆ GeoJSON Path Finder å¼•æ“ (å†…ç½®)
 * å¤„ç†è·¯ç½‘æ‹“æ‰‘è®¡ç®—
 */
function SimplePathFinder(geojson) {
    this.graph = {};
    geojson.features.forEach(feature => {
        const coords = feature.geometry.coordinates;
        for (let i = 0; i < coords.length - 1; i++) {
            const p1 = coords[i].slice(0, 2).join(',');
            const p2 = coords[i+1].slice(0, 2).join(',');
            const dist = Math.sqrt(Math.pow(coords[i][0]-coords[i+1][0], 2) + Math.pow(coords[i][1]-coords[i+1][1], 2));
            if (!this.graph[p1]) this.graph[p1] = {};
            if (!this.graph[p2]) this.graph[p2] = {};
            this.graph[p1][p2] = dist;
            this.graph[p2][p1] = dist;
        }
    });

    this.findPath = function(startPt, endPt) {
        // å¯»æ‰¾è·¯ç½‘ä¸Šç¦»ç‚¹å‡»ç‚¹æœ€è¿‘çš„ç‚¹
        const findNearest = (pt) => {
            let minKey = null, minDist = Infinity;
            Object.keys(this.graph).forEach(key => {
                const k = key.split(',').map(Number);
                const d = Math.pow(k[0]-pt[0], 2) + Math.pow(k[1]-pt[1], 2);
                if (d < minDist) { minDist = d; minKey = key; }
            });
            return minKey;
        };

        const startNode = findNearest(startPt);
        const endNode = findNearest(endPt);

        // Dijkstra ç®—æ³•
        let dists = {}, prev = {}, queue = new Set();
        Object.keys(this.graph).forEach(v => { dists[v] = Infinity; queue.add(v); });
        dists[startNode] = 0;

        while (queue.size > 0) {
            let u = null;
            queue.forEach(node => { if (u === null || dists[node] < dists[u]) u = node; });
            if (u === endNode || dists[u] === Infinity) break;
            queue.delete(u);

            for (let v in this.graph[u]) {
                let alt = dists[u] + this.graph[u][v];
                if (alt < dists[v]) { dists[v] = alt; prev[v] = u; }
            }
        }

        const path = [];
        for (let curr = endNode; curr; curr = prev[curr]) path.push(curr.split(',').map(Number));
        return { path: path.reverse(), weight: dists[endNode] };
    };
}

// åˆå§‹åŒ–åœ°å›¾
const map = L.map('map', { zoomControl: false, attributionControl: false }).setView([22.532, 113.936], 16);
let roadsData, pointsData, userLocation = null, currentRouteLayer = null, finder = null;

async function init() {
    try {
        const [g, w, b, r, p] = await Promise.all([
            fetch('green.json').then(res => res.json()),
            fetch('water.json').then(res => res.json()),
            fetch('buildings.json').then(res => res.json()),
            fetch('roads.json').then(res => res.json()),
            fetch('points.json').then(res => res.json())
        ]);

        // ç»˜åˆ¶åŸºç¡€åº•å›¾
        L.geoJSON(g, { style: { fillColor: "#C8E6C9", color: "#A5D6A7", weight: 0.5, fillOpacity: 0.7 } }).addTo(map);
        L.geoJSON(w, { style: { fillColor: "#B3E5FC", color: "#81D4FA", weight: 0.5, fillOpacity: 0.8 } }).addTo(map);
        L.geoJSON(b, { style: { fillColor: "#E0E0E0", color: "#BDBDBD", weight: 0.5, fillOpacity: 0.8 } }).addTo(map);
        L.geoJSON(r, { style: { color: "#ffffff", weight: 3, opacity: 0.8 } }).addTo(map);

        roadsData = r;
        pointsData = p;
        finder = new SimplePathFinder(r);

        // è®¾ç½®æœç´¢ç‚¹
        const list = document.getElementById('pointsList');
        L.geoJSON(p, {
            pointToLayer: (f, latlng) => L.circleMarker(latlng, { radius: 5, fillColor: "#800000", color: "#fff", weight: 1.5, fillOpacity: 1 }),
            onEachFeature: (f, layer) => {
                const name = f.properties.name || "æœªå‘½å";
                const opt = document.createElement('option');
                opt.value = name;
                list.appendChild(opt);
                layer.bindPopup(name);
            }
        }).addTo(map);

        document.getElementById('status-bar').innerText = "âœ… å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»é“è·¯è®¾ç½®èµ·ç‚¹";
    } catch (e) {
        document.getElementById('status-bar').innerText = "æ•°æ®åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ JSON æ–‡ä»¶";
        console.error(e);
    }
}

// äº¤äº’é€»è¾‘
map.on('click', e => {
    userLocation = [e.latlng.lng, e.latlng.lat];
    if (!window.uM) window.uM = L.circleMarker(e.latlng, { radius: 8, fillColor: '#007AFF', color: '#fff', weight: 3, fillOpacity: 1 }).addTo(map);
    else window.uM.setLatLng(e.latlng);
    document.getElementById('status-bar').innerText = "ğŸ“ èµ·ç‚¹å·²è®¾ç½®";
});

function triggerNav() {
    const val = document.getElementById('destInput').value;
    if (!userLocation) return alert("è¯·å…ˆåœ¨åœ°å›¾é“è·¯ä¸Šç‚¹ä¸€ä¸‹è®¾ç½®èµ·ç‚¹");
    
    const target = pointsData.features.find(f => f.properties.name === val);
    if (!target) return alert("æ²¡æ‰¾åˆ°è¯¥åœ°ç‚¹");

    const result = finder.findPath(userLocation, target.geometry.coordinates);

    if (result.path.length > 1) {
        if (currentRouteLayer) map.removeLayer(currentRouteLayer);
        // Leaflet åæ ‡æ˜¯ [lat, lng], ç®—æ³•è¾“å‡ºæ˜¯ [lng, lat]
        const latlngs = result.path.map(p => [p[1], p[0]]);
        currentRouteLayer = L.polyline(latlngs, { color: '#800000', weight: 8, opacity: 0.9, lineJoin: 'round' }).addTo(map);
        
        document.getElementById('targetName').innerText = val;
        document.getElementById('routeInfo').innerText = "å·²ä¸ºæ‚¨è§„åˆ’æœ€ä½³æ­¥è¡Œè·¯çº¿";
        document.getElementById('bottomNav').classList.add('show');
        document.getElementById('map').classList.add('shrink');
        map.fitBounds(currentRouteLayer.getBounds(), { padding: [50, 50] });
    } else {
        alert("è®¡ç®—å¤±è´¥ï¼Œè¯·ç‚¹å‡»ç™½è‰²é“è·¯é™„è¿‘é‡è¯•ã€‚");
    }
}

init();
</script>
</body>
</html>
