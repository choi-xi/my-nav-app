<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>æ·±å¤§æ™ºèƒ½å¯¼èˆª Pro</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root { --accent: #800000; --bg: #f4f4f7; --text: #333; --panel: rgba(255,255,255,0.95); }
        .dark-mode { --bg: #1a1a1a; --text: #eee; --panel: rgba(40,40,40,0.95); }
        
        body { margin: 0; background: var(--bg); color: var(--text); font-family: -apple-system, sans-serif; overflow: hidden; transition: background 0.5s ease; }
        #map { height: 100vh; width: 100vw; transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1); background: #ccc; }
        #map.shrink { height: 55vh; }

        /* é¡¶éƒ¨ UI */
        .top-ui { position: absolute; top: 15px; width: 92%; left: 4%; z-index: 1000; display: flex; flex-direction: column; gap: 10px; }
        .search-row { display: flex; gap: 8px; }
        #destInput { flex: 1; padding: 12px 16px; border-radius: 12px; border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.1); font-size: 16px; outline: none; }
        .mode-toggle { padding: 10px; border-radius: 12px; border: none; background: var(--panel); cursor: pointer; font-size: 18px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }

        /* åº•éƒ¨è·¯å¾„é¢æ¿ */
        .bottom-nav { position: fixed; bottom: 0; width: 100%; height: 45vh; background: var(--panel); transform: translateY(100%); transition: transform 0.4s ease; z-index: 1001; display: flex; flex-direction: column; }
        .bottom-nav.show { transform: translateY(0); }
        .route-tabs { display: flex; border-bottom: 1px solid #ddd; }
        .tab { flex: 1; padding: 15px 5px; text-align: center; cursor: pointer; font-weight: bold; font-size: 14px; opacity: 0.6; }
        .tab.active { opacity: 1; border-bottom: 3px solid var(--accent); color: var(--accent); }
        .route-detail { padding: 20px; overflow-y: auto; flex: 1; }

        /* åŠ¨ç”»æç¤º */
        .leaflet-popup-content-wrapper { border-radius: 12px; padding: 5px; }
        .nav-btn-mini { background: var(--accent); color: white; border: none; padding: 8px 15px; border-radius: 6px; margin-top: 8px; width: 100%; cursor: pointer; }
        
        #status-bar { position: absolute; top: 120px; left: 5%; z-index: 1000; font-size: 11px; background: rgba(0,0,0,0.6); color: white; padding: 4px 10px; border-radius: 4px; }
    </style>
</head>
<body>

<div class="top-ui">
    <div class="search-row">
        <input type="text" id="destInput" list="pointsList" placeholder="æœç´¢æ ¡å†…åœ°ç‚¹..." oninput="handleSearch(this.value)">
        <datalist id="pointsList"></datalist>
        <button class="mode-toggle" onclick="toggleTheme()" id="themeBtn">â˜€ï¸</button>
    </div>
</div>

<div id="status-bar">æ­£åœ¨åŠ è½½æ ¡åŒºèµ„æº...</div>
<div id="map"></div>

<div class="bottom-nav" id="bottomNav">
    <div class="route-tabs">
        <div class="tab active" onclick="switchRoute(0)" id="tab0">æœ€ä¼˜è·¯å¾„</div>
        <div class="tab" onclick="switchRoute(1)" id="tab1">å¤‡é€‰ä¸€</div>
        <div class="tab" onclick="switchRoute(2)" id="tab2">å¤‡é€‰äºŒ</div>
    </div>
    <div class="route-detail" id="routeDetail">
        <h3 id="targetTitle" style="margin-top:0;">ç›®çš„åœ°</h3>
        <p id="routeDesc">è¯·é€‰æ‹©ä¸€æ¡è·¯å¾„æŸ¥çœ‹è¯¦æƒ…</p>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/** æ ¸å¿ƒå¯¼èˆªå¼•æ“ï¼šæ”¯æŒåŠ¨æ€æƒé‡å’Œè·¯å¾„å»é‡ **/
class SmartNavEngine {
    constructor(geojson) {
        this.nodes = new Map();
        geojson.features.forEach(f => {
            const coords = f.geometry.coordinates.map(c => [c[0], c[1]]);
            const props = f.properties;
            for (let i = 0; i < coords.length - 1; i++) {
                this.addEdge(coords[i].join(','), coords[i+1].join(','), props);
            }
        });
    }

    addEdge(p1, p2, props) {
        if (!this.nodes.has(p1)) this.nodes.set(p1, []);
        if (!this.nodes.has(p2)) this.nodes.set(p2, []);
        const edge = {
            to: p2,
            length: this.calcDist(p1.split(','), p2.split(',')),
            width: props.Width || 2,
            env: props.Environment || 3,
            safe: props.Safety || 3
        };
        this.nodes.get(p1).push(edge);
        this.nodes.get(p2).push({...edge, to: p1});
    }

    calcDist(c1, c2) { return Math.sqrt(Math.pow(c1[0]-c2[0], 2) + Math.pow(c1[1]-c2[1], 2)); }

    // Dijkstra æ ¸å¿ƒï¼Œæ”¯æŒä¼ å…¥æƒé‡å‡½æ•°
    findPath(startPt, endPt, weightFn) {
        const findNearest = (pt) => {
            let nearest = null, minD = Infinity;
            for (let key of this.nodes.keys()) {
                const k = key.split(',').map(Number);
                const d = Math.pow(k[0]-pt[0], 2) + Math.pow(k[1]-pt[1], 2);
                if (d < minD) { minD = d; nearest = key; }
            }
            return nearest;
        };

        const start = findNearest(startPt), target = findNearest(endPt);
        let dists = {}, prev = {}, pq = [{node: start, d: 0}];
        for (let n of this.nodes.keys()) dists[n] = Infinity;
        dists[start] = 0;

        while (pq.length > 0) {
            pq.sort((a,b) => a.d - b.d);
            const {node: u} = pq.shift();
            if (u === target) break;
            for (let edge of this.nodes.get(u)) {
                let cost = weightFn(edge);
                if (dists[u] + cost < dists[edge.to]) {
                    dists[edge.to] = dists[u] + cost;
                    prev[edge.to] = u;
                    pq.push({node: edge.to, d: dists[edge.to]});
                }
            }
        }
        const path = [];
        for (let at = target; at; at = prev[at]) path.push(at.split(',').map(Number));
        return path.reverse();
    }
}

// åˆå§‹åŒ–åº”ç”¨
let isDark = false;
const map = L.map('map', { zoomControl: false, attributionControl: false }).setView([22.532, 113.936], 16);
let engine, pointsData, userLocation, routes = [], layers = [];

async function init() {
    try {
        const [g, w, b, r, p] = await Promise.all([
            fetch('green.json').then(res => res.json()),
            fetch('water.json').then(res => res.json()),
            fetch('buildings.json').then(res => res.json()),
            fetch('roads.json').then(res => res.json()),
            fetch('points.json').then(res => res.json())
        ]);

        layers.green = L.geoJSON(g, { style: { fillColor: "#C8E6C9", color: "#A5D6A7", weight: 0.5, fillOpacity: 0.7 } }).addTo(map);
        layers.water = L.geoJSON(w, { style: { fillColor: "#B3E5FC", color: "#81D4FA", weight: 0.5, fillOpacity: 0.8 } }).addTo(map);
        layers.buildings = L.geoJSON(b, { style: { fillColor: "#E0E0E0", color: "#BDBDBD", weight: 0.5, fillOpacity: 0.8 } }).addTo(map);
        layers.roads = L.geoJSON(r, { style: { color: "#ffffff", weight: 3, opacity: 0.7 } }).addTo(map);

        engine = new SmartNavEngine(r);
        pointsData = p;

        const list = document.getElementById('pointsList');
        L.geoJSON(p, {
            pointToLayer: (f, latlng) => L.circleMarker(latlng, { radius: 6, fillColor: "#800000", color: "#fff", weight: 2, fillOpacity: 1 }),
            onEachFeature: (f, layer) => {
                const name = f.properties.name || "æœªå‘½ååœ°ç‚¹";
                const opt = document.createElement('option'); opt.value = name; list.appendChild(opt);
                layer.bindPopup(`<strong>${name}</strong><br><button class="nav-btn-mini" onclick="startNav('${name}')">åˆ°è¿™å»</button>`);
            }
        }).addTo(map);

        document.getElementById('status-bar').innerText = "åœ°å›¾å·²å°±ç»ªï¼Œç‚¹å‡»è·¯é¢è®¾ç½®èµ·ç‚¹";
    } catch (e) { document.getElementById('status-bar').innerText = "åŠ è½½å¤±è´¥"; }
}

// ä¸»å¯¼èˆªé€»è¾‘
function startNav(targetName) {
    if (!userLocation) return alert("è¯·å…ˆç‚¹å‡»åœ°å›¾è®¾ç½®èµ·ç‚¹");
    const target = pointsData.features.find(f => f.properties.name === targetName);
    const destCoords = target.geometry.coordinates;
    
    routes = [];
    const configs = isDark ? [
        { name: "æ›´å®‰å…¨ (æœ€ä¼˜)", w: {l:0.2, w:0.2, e:0.2, s:0.4} },
        { name: "æ›´çŸ­ (å¤‡é€‰ä¸€)", w: {l:0.5, w:0.2, e:0.0, s:0.3} },
        { name: "ç¯å¢ƒæ›´å¥½ (å¤‡é€‰äºŒ)", w: {l:0.2, w:0.2, e:0.4, s:0.2} }
    ] : [
        { name: "æ›´èˆ’é€‚ (æœ€ä¼˜)", w: {l:0.2, w:0.2, e:0.4, s:0.2} },
        { name: "æ›´çŸ­ (å¤‡é€‰ä¸€)", w: {l:0.5, w:0.2, e:0.3, s:0.0} },
        { name: "æ›´å®‰å…¨ (å¤‡é€‰äºŒ)", w: {l:0.3, w:0.3, e:0.0, s:0.4} }
    ];

    configs.forEach((cfg, idx) => {
        let path = engine.findPath(userLocation, destCoords, e => (e.length*cfg.w.l + (10-e.width)*cfg.w.w + (10-e.env)*cfg.w.e + (10-e.safe)*cfg.w.s));
        
        // å»é‡é€»è¾‘ï¼šå¦‚æœä¸ä¹‹å‰è·¯å¾„é‡å¤ï¼Œå¢åŠ  length æƒé‡
        if (idx > 0 && JSON.stringify(path) === JSON.stringify(routes[0].path)) {
            path = engine.findPath(userLocation, destCoords, e => (e.length*(cfg.w.l+0.3) + (10-e.width)*cfg.w.w));
        }
        routes.push({ path, ...cfg });
    });

    switchRoute(0);
    document.getElementById('targetTitle').innerText = targetName;
    document.getElementById('bottomNav').classList.add('show');
    document.getElementById('map').classList.add('shrink');
}

let activeLayer = null;
function switchRoute(idx) {
    if (activeLayer) map.removeLayer(activeLayer);
    const r = routes[idx];
    activeLayer = L.polyline(r.path.map(p => [p[1], p[0]]), { color: idx===0?'#800000':'#555', weight: 8, opacity: 0.9 }).addTo(map);
    
    document.querySelectorAll('.tab').forEach((t, i) => t.className = i===idx ? 'tab active' : 'tab');
    document.getElementById('routeDesc').innerHTML = `
        <strong>æ–¹æ¡ˆï¼š${r.name}</strong><br>
        é¢„è®¡æ­¥è¡Œè·ç¦»ï¼š${Math.round(r.path.length * 10)} ç±³<br>
        è·¯æ®µå»ºè®®ï¼šæ­¤è·¯å¾„ç»ç”±ä¸»è¦é“è·¯ï¼Œå®‰å…¨ç³»æ•°é«˜ï¼Œé€‚åˆ${isDark?'å¤œé—´è¡Œèµ°':'èˆ’é€‚æ­¥è¡Œ'}ã€‚
    `;
    map.fitBounds(activeLayer.getBounds(), { padding: [30, 30] });
}

// ç•Œé¢äº¤äº’
function toggleTheme() {
    isDark = !isDark;
    document.body.classList.toggle('dark-mode');
    document.getElementById('themeBtn').innerText = isDark ? "ğŸŒ™" : "â˜€ï¸";
    
    const darkStyles = {
        green: { fillColor: "#1b3322", color: "#2d5a27" },
        water: { fillColor: "#0e2a35", color: "#1a4d5f" },
        buildings: { fillColor: "#333", color: "#444" },
        roads: { color: "#555", opacity: 0.5 }
    };
    const lightStyles = {
        green: { fillColor: "#C8E6C9", color: "#A5D6A7" },
        water: { fillColor: "#B3E5FC", color: "#81D4FA" },
        buildings: { fillColor: "#E0E0E0", color: "#BDBDBD" },
        roads: { color: "#ffffff", opacity: 0.7 }
    };
    
    const s = isDark ? darkStyles : lightStyles;
    layers.green.setStyle(s.green);
    layers.water.setStyle(s.water);
    layers.buildings.setStyle(s.buildings);
    layers.roads.setStyle(s.roads);
}

function handleSearch(val) {
    if (pointsData.features.some(f => f.properties.name === val)) startNav(val);
}

map.on('click', e => {
    userLocation = [e.latlng.lng, e.latlng.lat];
    if (!window.uM) window.uM = L.circleMarker(e.latlng, { radius: 8, fillColor: '#007AFF', color: '#fff', weight: 3, fillOpacity: 1 }).addTo(map);
    else window.uM.setLatLng(e.latlng);
    document.getElementById('status-bar').innerText = "èµ·ç‚¹å·²è®¾ï¼Œè¯·è¾“å…¥ç»ˆç‚¹";
});

init();
</script>
</body>
</html>
