<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>æ·±å¤§æ™ºèƒ½å¯¼èˆª - äº¤äº’å¢å¼ºç‰ˆ</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root { --accent: #800000; --bg: #f4f4f7; --text: #333; --panel: rgba(255,255,255,0.98); }
        .dark-mode { --bg: #1a1a1a; --text: #eee; --panel: rgba(45,45,45,0.98); }
        
        body { margin: 0; background: var(--bg); color: var(--text); font-family: -apple-system, sans-serif; overflow: hidden; transition: background 0.5s ease; }
        #map { height: 100vh; width: 100vw; transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1); background: #ddd; }
        #map.shrink { height: 60vh; }
        #map.mini-shrink { height: 90vh; }

        /* é¡¶éƒ¨ UI å¸ƒå±€ä¼˜åŒ– */
        .top-ui { position: absolute; top: 15px; width: 92%; left: 4%; z-index: 1000; display: flex; flex-direction: column; gap: 10px; }
        .search-row { display: flex; gap: 6px; align-items: stretch; }
        .input-group { flex: 1; display: flex; background: #fff; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); overflow: hidden; }
        #destInput { flex: 1; padding: 12px 16px; border: none; font-size: 16px; outline: none; background: transparent; }
        
        /* æœç´¢æ¡†æ—çš„å¯¼èˆªæŒ‰é”® */
        .nav-trigger-btn { padding: 0 15px; border: none; background: transparent; cursor: pointer; font-size: 18px; color: var(--accent); border-left: 1px solid #eee; display: flex; align-items: center; justify-content: center; }
        .nav-trigger-btn:active { background: #f0f0f0; }

        .mode-toggle { width: 46px; height: 46px; border-radius: 12px; border: none; background: #fff; cursor: pointer; font-size: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center; }

        /* åº•éƒ¨å¯¼èˆªé¢æ¿ */
        .bottom-nav { position: fixed; bottom: 0; width: 100%; height: 40vh; background: var(--panel); transform: translateY(100%); transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); z-index: 1001; border-radius: 20px 20px 0 0; box-shadow: 0 -5px 20px rgba(0,0,0,0.1); }
        .bottom-nav.show { transform: translateY(0); }
        .bottom-nav.collapsed { height: 65px; transform: translateY(0); }

        .nav-header { display: flex; align-items: center; border-bottom: 1px solid rgba(0,0,0,0.08); padding-right: 15px; }
        .route-tabs { flex: 1; display: flex; padding: 0 5px; }
        .tab { flex: 1; padding: 20px 5px; text-align: center; cursor: pointer; font-weight: bold; font-size: 14px; opacity: 0.4; transition: 0.3s; white-space: nowrap; }
        .tab.active { opacity: 1; color: var(--accent); border-bottom: 3px solid var(--accent); }

        .fold-btn { background: #f0f0f0; border: none; font-size: 12px; cursor: pointer; padding: 6px 12px; border-radius: 20px; color: var(--text); font-weight: bold; }
        .dark-mode .fold-btn { background: #333; }

        .route-detail { padding: 20px; overflow-y: auto; height: calc(40vh - 65px); transition: opacity 0.3s; }
        .collapsed .route-detail { opacity: 0; pointer-events: none; }
        
        #status-bar { position: absolute; top: 75px; left: 5%; z-index: 1000; font-size: 11px; background: rgba(0,0,0,0.7); color: white; padding: 4px 12px; border-radius: 4px; pointer-events: none; }
    </style>
</head>
<body>

<div class="top-ui">
    <div class="search-row">
        <div class="input-group">
            <input type="text" id="destInput" list="pointsList" placeholder="è¾“å…¥ç›®çš„åœ°å¹¶æŒ‰å›è½¦..." onkeydown="checkEnter(event)">
            <button class="nav-trigger-btn" onclick="triggerNav()" title="å¼€å§‹å¯¼èˆª">ğŸš€</button>
        </div>
        <datalist id="pointsList"></datalist>
        <button class="mode-toggle" onclick="toggleTheme()" id="themeBtn">â˜€ï¸</button>
    </div>
</div>

<div id="status-bar">å®šä½ä¸­...</div>
<div id="map"></div>

<div class="bottom-nav" id="bottomNav">
    <div class="nav-header">
        <div class="route-tabs" id="tabContainer"></div>
        <button class="fold-btn" onclick="toggleFold()" id="foldBtn">æ”¶èµ·</button>
    </div>
    <div class="route-detail" id="routeDetail">
        <h3 id="targetTitle" style="margin:0 0 10px 0;">ç›®çš„åœ°</h3>
        <p id="routeDesc"></p>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/** å¯¼èˆªæ ¸å¿ƒå¼•æ“ **/
class MultiWeightEngine {
    constructor(geojson) {
        this.graph = new Map();
        geojson.features.forEach(f => {
            const coords = f.geometry.coordinates;
            const p = f.properties;
            for (let i = 0; i < coords.length - 1; i++) {
                this.addEdge(coords[i].join(','), coords[i+1].join(','), p);
            }
        });
    }
    addEdge(p1, p2, p) {
        if (!this.graph.has(p1)) this.graph.set(p1, []);
        if (!this.graph.has(p2)) this.graph.set(p2, []);
        const c1 = p1.split(','), c2 = p2.split(',');
        const dist = Math.sqrt(Math.pow(c1[0]-c2[0], 2) + Math.pow(c1[1]-c2[1], 2));
        const edge = { to: p2, l: dist, w: p.Width||3, e: p.Environment||3, s: p.Safety||3 };
        this.graph.get(p1).push(edge);
        this.graph.get(p2).push({...edge, to: p1});
    }
    findPath(startPt, endPt, weightFn) {
        const findN = (pt) => {
            let n = null, min = Infinity;
            for (let k of this.graph.keys()) {
                const c = k.split(',').map(Number);
                const d = Math.pow(c[0]-pt[0],2)+Math.pow(c[1]-pt[1],2);
                if(d < min) { min = d; n = k; }
            }
            return n;
        };
        const s = findN(startPt), t = findN(endPt);
        if(!s || !t) return [];
        let dists = {}, prev = {}, pq = [{n: s, d: 0}];
        for (let k of this.graph.keys()) dists[k] = Infinity;
        dists[s] = 0;
        while (pq.length > 0) {
            pq.sort((a,b) => a.d - b.d);
            const {n:u} = pq.shift();
            if (u === t) break;
            for (let e of this.graph.get(u)) {
                let cost = weightFn(e);
                if (dists[u] + cost < dists[e.to]) {
                    dists[e.to] = dists[u] + cost;
                    prev[e.to] = u;
                    pq.push({n: e.to, d: dists[e.to]});
                }
            }
        }
        const path = [];
        for (let curr = t; curr; curr = prev[curr]) path.push(curr.split(',').map(Number));
        return path.reverse();
    }
}

const map = L.map('map', { zoomControl: false, attributionControl: false }).setView([22.532, 113.936], 16);
let engine, pointsData, userLocation, isDark = false, routes = [], activePolyline = null, layers = {};

async function init() {
    try {
        const [g, w, b, r, p] = await Promise.all([
            fetch('green.json').then(res => res.json()),
            fetch('water.json').then(res => res.json()),
            fetch('buildings.json').then(res => res.json()),
            fetch('roads.json').then(res => res.json()),
            fetch('points.json').then(res => res.json())
        ]);
        layers.green = L.geoJSON(g, { style: { fillColor: "#C8E6C9", color: "#A5D6A7", weight: 0.5, fillOpacity: 0.7 } }).addTo(map);
        layers.water = L.geoJSON(w, { style: { fillColor: "#B3E5FC", color: "#81D4FA", weight: 0.5, fillOpacity: 0.8 } }).addTo(map);
        layers.buildings = L.geoJSON(b, { style: { fillColor: "#E0E0E0", color: "#BDBDBD", weight: 0.5, fillOpacity: 0.8 } }).addTo(map);
        layers.roads = L.geoJSON(r, { style: { color: "#ffffff", weight: 3, opacity: 0.7 } }).addTo(map);
        engine = new MultiWeightEngine(r);
        pointsData = p;
        const list = document.getElementById('pointsList');
        L.geoJSON(p, {
            pointToLayer: (f, latlng) => L.circleMarker(latlng, { radius: 6, fillColor: "#800000", color: "#fff", weight: 2, fillOpacity: 1 }),
            onEachFeature: (f, layer) => {
                const name = f.properties.name;
                const opt = document.createElement('option'); opt.value = name; list.appendChild(opt);
                layer.on('click', () => startNav(name));
            }
        }).addTo(map);
        document.getElementById('status-bar').innerText = "ğŸ“ è¯·å…ˆç‚¹å‡»åœ°å›¾è®¾ç½®èµ·ç‚¹";
    } catch (e) { document.getElementById('status-bar').innerText = "âŒ åŠ è½½å¤±è´¥"; }
}

// å“åº”å›è½¦é”®
function checkEnter(e) {
    if (e.key === 'Enter') triggerNav();
}

// è§¦å‘å¯¼èˆª
function triggerNav() {
    const val = document.getElementById('destInput').value;
    const exists = pointsData.features.some(f => f.properties.name === val);
    if (exists) {
        startNav(val);
        document.getElementById('destInput').blur(); // éšè—æ‰‹æœºé”®ç›˜
    } else if (val) {
        alert("æœªæ‰¾åˆ°è¯¥åœ°ç‚¹ï¼Œè¯·ä»åˆ—è¡¨ä¸­é€‰æ‹©");
    }
}

function startNav(targetName) {
    if (!userLocation) return alert("è¯·å…ˆç‚¹å‡»åœ°å›¾è®¾ç½®èµ·ç‚¹");
    const target = pointsData.features.find(f => f.properties.name === targetName);
    const dest = target.geometry.coordinates;
    
    // æƒé‡ç­–ç•¥
    const configs = isDark ? [
        { label:"æ›´å®‰å…¨(æœ€ä¼˜)", w: e => e.l*0.2 + (10-e.w)*0.2 + (10-e.e)*0.2 + (10-e.s)*0.4 },
        { label:"æ›´çŸ­(å¤‡é€‰ä¸€)", w: e => e.l*0.5 + (10-e.w)*0.2 + (10-e.s)*0.3 },
        { label:"ç¯å¢ƒæ›´å¥½(å¤‡é€‰äºŒ)", w: e => e.l*0.2 + (10-e.w)*0.2 + (10-e.s)*0.2 + (10-e.e)*0.4 }
    ] : [
        { label:"æ›´èˆ’é€‚(æœ€ä¼˜)", w: e => e.l*0.2 + (10-e.w)*0.2 + (10-e.e)*0.4 + (10-e.s)*0.2 },
        { label:"æ›´çŸ­(å¤‡é€‰ä¸€)", w: e => e.l*0.5 + (10-e.w)*0.2 + (10-e.e)*0.3 },
        { label:"æ›´å®‰å…¨(å¤‡é€‰äºŒ)", w: e => e.l*0.3 + (10-e.w)*0.3 + (10-e.s)*0.4 }
    ];

    routes = [];
    configs.forEach((cfg, idx) => {
        let path = engine.findPath(userLocation, dest, cfg.w);
        let pStr = JSON.stringify(path);
        // ä¸¥æ ¼å»é‡ï¼šå¦‚æœå¤‡é€‰è·¯å¾„ä¸æœ€ä¼˜è·¯å¾„é‡åˆï¼Œåˆ™ä¸æ·»åŠ 
        if (idx === 0 || !routes.some(r => r.pStr === pStr)) {
            routes.push({ ...cfg, path, pStr });
        }
    });

    renderUI(targetName);
}

function renderUI(name) {
    const container = document.getElementById('tabContainer');
    container.innerHTML = "";
    routes.forEach((r, i) => {
        const div = document.createElement('div');
        div.className = `tab ${i===0?'active':''}`;
        div.innerText = r.label;
        div.onclick = () => switchRoute(i);
        container.appendChild(div);
    });
    document.getElementById('targetTitle').innerText = name;
    document.getElementById('bottomNav').className = "bottom-nav show";
    document.getElementById('map').className = "shrink";
    document.getElementById('foldBtn').innerText = "æ”¶èµ·å†…å®¹";
    switchRoute(0);
}

function switchRoute(idx) {
    if (activePolyline) map.removeLayer(activePolyline);
    const r = routes[idx];
    activePolyline = L.polyline(r.path.map(p => [p[1], p[0]]), { color: idx===0?'#800000':'#666', weight: 8, opacity: 0.9 }).addTo(map);
    document.querySelectorAll('.tab').forEach((t, i) => t.className = i===idx ? 'tab active' : 'tab');
    document.getElementById('routeDesc').innerText = `å·²é€‰æ–¹æ¡ˆï¼š${r.label}ã€‚å…¨é•¿çº¦ ${Math.round(r.path.length * 11000)} ç±³ã€‚`;
    map.fitBounds(activePolyline.getBounds(), { padding: [40, 40] }); // è‡ªåŠ¨ç¼©æ”¾
}

function toggleFold() {
    const nav = document.getElementById('bottomNav');
    const mapEl = document.getElementById('map');
    const isCollapsed = nav.classList.toggle('collapsed');
    mapEl.className = isCollapsed ? "mini-shrink" : "shrink";
    document.getElementById('foldBtn').innerText = isCollapsed ? "å±•å¼€è¯¦æƒ…" : "æ”¶èµ·å†…å®¹";
    setTimeout(() => map.invalidateSize(), 400);
}

function toggleTheme() {
    isDark = !isDark;
    document.body.classList.toggle('dark-mode');
    document.getElementById('themeBtn').innerText = isDark ? "ğŸŒ™" : "â˜€ï¸";
    const s = isDark ? {
        green: { fillColor: "#1b3322", color: "#2d5a27" },
        water: { fillColor: "#0e2a35", color: "#1a4d5f" },
        buildings: { fillColor: "#333", color: "#444" },
        roads: { color: "#444", opacity: 0.5 }
    } : {
        green: { fillColor: "#C8E6C9", color: "#A5D6A7" },
        water: { fillColor: "#B3E5FC", color: "#81D4FA" },
        buildings: { fillColor: "#E0E0E0", color: "#BDBDBD" },
        roads: { color: "#ffffff", opacity: 0.7 }
    };
    Object.keys(s).forEach(k => layers[k].setStyle(s[k]));
}

map.on('click', e => {
    userLocation = [e.latlng.lng, e.latlng.lat];
    if (!window.uM) window.uM = L.circleMarker(e.latlng, { radius: 8, fillColor: '#007AFF', color: '#fff', weight: 3, fillOpacity: 1 }).addTo(map);
    else window.uM.setLatLng(e.latlng);
    document.getElementById('status-bar').innerText = "âœ… èµ·ç‚¹å·²å°±ç»ª";
});

init();
</script>
</body>
</html>
