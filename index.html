<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>æ·±å¤§æ™ºèƒ½å¯¼èˆª - è·¨æ ¡åŒºç‰ˆ</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        :root { --bg: #ffffff; --text: #333; --panel: rgba(255,255,255,0.95); --accent: #800000; }
        body.dark-mode { --bg: #121212; --text: #e0e0e0; --panel: rgba(30,30,30,0.95); --accent: #ff4d4d; }
        
        body { margin: 0; transition: background 0.8s cubic-bezier(0.4, 0, 0.2, 1); background: var(--bg); font-family: -apple-system, sans-serif; overflow: hidden; }
        #map { height: 65vh; width: 100vw; transition: filter 0.8s ease; }
        body.dark-mode #map { filter: brightness(0.6) grayscale(0.3) contrast(1.2); }

        /* UI ç»„ä»¶ */
        .top-bar { position: absolute; top: 15px; width: 90%; left: 5%; z-index: 1000; display: flex; gap: 10px; }
        input { flex: 1; padding: 12px 20px; border-radius: 25px; border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.1); font-size: 16px; outline: none; background: var(--panel); color: var(--text); }
        .theme-btn { background: var(--panel); border: none; width: 45px; height: 45px; border-radius: 50%; cursor: pointer; font-size: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center; }

        /* åº•éƒ¨ä¸‰åŒºåŸŸ */
        .bottom-nav { position: fixed; bottom: 0; width: 100%; height: 35vh; background: var(--panel); color: var(--text); display: flex; flex-direction: column; border-top: 1px solid rgba(0,0,0,0.1); z-index: 1001; }
        .nav-tabs { display: flex; height: 100%; }
        .nav-card { flex: 1; padding: 15px 10px; border-right: 1px solid rgba(0,0,0,0.05); display: flex; flex-direction: column; cursor: pointer; transition: 0.3s; position: relative; }
        .nav-card:last-child { border-right: none; }
        .nav-card.active { background: rgba(128, 0, 0, 0.05); }
        .nav-card h4 { margin: 0 0 8px 0; font-size: 14px; color: var(--accent); }
        .nav-card .desc { font-size: 11px; line-height: 1.4; overflow-y: auto; flex-grow: 1; }
        .nav-card .meta { font-size: 10px; font-weight: bold; margin-top: 5px; color: #666; }
    </style>
</head>
<body>

<div class="top-bar">
    <input type="text" id="destInput" placeholder="è¾“å…¥ç›®çš„åœ°(å¦‚: åŠå…¬æ¥¼)...">
    <button class="theme-btn" onclick="toggleTheme()">ğŸŒ“</button>
</div>

<div id="map"></div>

<div class="bottom-nav">
    <div class="nav-tabs">
        <div class="nav-card" id="card-best" onclick="selectRoute('best')">
            <h4 id="h-best">æœ€ä¼˜è·¯å¾„</h4>
            <div class="desc" id="d-best">å¾…è®¡ç®—...</div>
            <div class="meta" id="m-best"></div>
        </div>
        <div class="nav-card" id="card-alt1" onclick="selectRoute('alt1')">
            <h4 id="h-alt1">å¤‡é€‰ä¸€</h4>
            <div class="desc" id="d-alt1">å¾…è®¡ç®—...</div>
            <div class="meta" id="m-alt1"></div>
        </div>
        <div class="nav-card" id="card-alt2" onclick="selectRoute('alt2')">
            <h4 id="h-alt2">å¤‡é€‰äºŒ</h4>
            <div class="desc" id="d-alt2">å¾…è®¡ç®—...</div>
            <div class="meta" id="m-alt2"></div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/geojson-path-finder/dist/geojson-path-finder.min.js"></script>

<script>
    // --- 1. åˆå§‹åŒ–åœ°å›¾ä¸èŒƒå›´é™åˆ¶ (æ·±åœ³å¤§å­¦ç²¤æµ·+æ²§æµ·æ ¡åŒº) ---
    const szuBounds = [
        [22.518, 113.925], // è¥¿å—è§’
        [22.545, 113.945]  // ä¸œåŒ—è§’
    ];
    const map = L.map('map', {
        maxBounds: szuBounds,
        maxBoundsViscosity: 1.0,
        minZoom: 14
    }).setView([22.533, 113.935], 16);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    let isNight = false;
    let roadsData, pointsData, userLocation;
    let computedRoutes = {}; // å­˜å‚¨è®¡ç®—å‡ºçš„ä¸‰æ¡è·¯å¾„å¯¹è±¡

    // --- 2. åŠ è½½æ•°æ® ---
    Promise.all([
        fetch('roads.json').then(r => r.json()),
        fetch('points.json').then(r => r.json())
    ]).then(([roads, points]) => {
        roadsData = roads; 
        pointsData = points;
        L.geoJSON(roads, { style: { color: '#ccc', weight: 1, opacity: 0.3 } }).addTo(map);
    });

    // --- 3. ä¸»é¢˜åˆ‡æ¢é€»è¾‘ ---
    function toggleTheme() {
        isNight = !isNight;
        document.body.classList.toggle('dark-mode');
        const h = {
            best: isNight ? "æ›´å®‰å…¨(æœ€ä¼˜)" : "æ›´èˆ’é€‚(æœ€ä¼˜)",
            alt1: "æ›´çŸ­è·ç¦»",
            alt2: isNight ? "ç¯å¢ƒæ›´å¥½" : "æ›´å®‰å…¨"
        };
        document.getElementById('h-best').innerText = h.best;
        document.getElementById('h-alt2').innerText = h.alt2;
        if(computedRoutes.best) calculateAll(); // åˆ‡æ¢æ—¶é‡æ–°è®¡ç®—
    }

    // --- 4. æ ¸å¿ƒç®—æ³•ï¼šæƒé‡ä¸æ’ä»–æ€§é€»è¾‘ ---
    function getWeight(props, type, mode, penaltyNodes = []) {
        let { length: L, width: W, env: E, safe: S } = props;
        L = L || 0.1; W = W || 1; E = E || 1; S = S || 1;

        // æ’ä»–æ€§æƒ©ç½šï¼šå¦‚æœè¯¥è·¯æ®µåœ¨å·²æœ‰è·¯å¾„ä¸­ï¼Œæƒé‡æ¿€å¢ 100 å€
        const isUsed = penaltyNodes.includes(props.id);
        const penalty = isUsed ? 100 : 1;

        let weight = 0;
        if (!mode) { // ç™½å¤©é€»è¾‘
            if (type === 'best') weight = (L*0.2 + W*0.2 + E*0.4 + S*0.2);
            if (type === 'alt1') weight = (L*0.5 + W*0.2 + E*0.3);
            if (type === 'alt2') weight = (L*0.3 + W*0.3 + S*0.4);
        } else { // é»‘å¤œé€»è¾‘
            if (type === 'best') weight = (L*0.2 + W*0.2 + E*0.2 + S*0.4);
            if (type === 'alt1') weight = (L*0.5 + W*0.2 + S*0.3);
            if (type === 'alt2') weight = (L*0.2 + W*0.2 + S*0.2 + E*0.4);
        }
        return weight * penalty;
    }

    // --- 5. è·¯å¾„è®¡ç®—ä¸å†²çªè°ƒæ•´ ---
    function solvePath(type, penaltyIds = [], lBoost = 0) {
        const pathFinder = new geojsonPathFinder(roadsData, {
            weightFn: (a, b, props) => getWeight(props, type, isNight, penaltyIds) + (lBoost * props.length)
        });
        // æ¨¡æ‹Ÿå½“å‰ä½ç½®åˆ°ç›®çš„åœ°ï¼ˆå®é™…éœ€é€šè¿‡ GPS å’Œè¾“å…¥è·å–ï¼‰
        const destName = document.getElementById('destInput').value;
        const dest = pointsData.features.find(f => f.properties.name === destName);
        if(!dest || !userLocation) return null;

        return pathFinder.findPath(
            { geometry: { coordinates: [userLocation.lng, userLocation.lat] } },
            { geometry: { coordinates: dest.geometry.coordinates } }
        );
    }

    async function calculateAll() {
        if(!userLocation) return alert("ç­‰å¾…å®šä½ä¸­...");
        
        // 1. è®¡ç®—æœ€ä¼˜
        let best = solvePath('best');
        
        // 2. è®¡ç®—å¤‡é€‰ä¸€ï¼ˆå¢åŠ æ’ä»–æ€§ï¼Œè‹¥é‡å¤åˆ™è°ƒé«˜ L æƒé‡ï¼‰
        let usedIds = best ? best.edgeInfos.map(e => e.id) : [];
        let alt1 = solvePath('alt1', usedIds);
        let lAdjust1 = 0;
        while(alt1 && JSON.stringify(alt1.path) === JSON.stringify(best?.path) && lAdjust1 < 2) {
            lAdjust1 += 0.5; // ä¼˜å…ˆè°ƒæ•´ length å æ¯”
            alt1 = solvePath('alt1', usedIds, lAdjust1);
        }

        // 3. è®¡ç®—å¤‡é€‰äºŒ
        let allUsedIds = [...usedIds, ...(alt1 ? alt1.edgeInfos.map(e => e.id) : [])];
        let alt2 = solvePath('alt2', allUsedIds);
        // ...åŒæ ·çš„ while å¾ªç¯é€»è¾‘è¿›è¡Œè°ƒä¼˜...

        computedRoutes = { best, alt1, alt2 };
        updateUI();
    }

    // --- 6. å®šä½ä¸äº¤äº’ ---
    map.on('locationfound', e => {
        userLocation = e.latlng;
        L.circleMarker(e.latlng, {radius: 7, color: '#800000'}).addTo(map);
    });
    map.locate({setView: true, watch: true});

    function selectRoute(type) {
        const colors = { best: '#800000', alt1: '#007AFF', alt2: '#34C759' };
        Object.values(computedRoutes).forEach(r => r?.layer && map.removeLayer(r.layer));
        
        const r = computedRoutes[type];
        if(r) {
            r.layer = L.polyline(r.path.map(p => [p[1], p[0]]), {color: colors[type], weight: 6}).addTo(map);
            map.fitBounds(r.layer.getBounds());
        }
    }

    function updateUI() {
        ['best', 'alt1', 'alt2'].forEach(t => {
            const r = computedRoutes[t];
            const div = document.getElementById('d-' + t);
            const meta = document.getElementById('m-' + t);
            if(r) {
                div.innerHTML = `ç»è¿‡: ${r.path.length}ä¸ªèŠ‚ç‚¹<br>è·¯å†µ: ${isNight?'ç…§æ˜å……è¶³':'é£æ™¯ä¼˜ç¾'}`;
                meta.innerText = `ä¼°è®¡: ${(r.weight*100).toFixed(0)}ç±³`;
            }
        });
    }
</script>
</body>
</html>