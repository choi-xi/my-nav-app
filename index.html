<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>æ·±å¤§æ™ºèƒ½å¯¼èˆªç³»ç»Ÿ</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        :root { --bg: #ffffff; --text: #333; --panel: rgba(255,255,255,0.95); --accent: #800000; }
        body.dark-mode { --bg: #121212; --text: #e0e0e0; --panel: rgba(30,30,30,0.95); --accent: #ff4d4d; }
        
        body { margin: 0; transition: background 0.8s ease; background: var(--bg); font-family: -apple-system, sans-serif; overflow: hidden; }
        #map { height: 60vh; width: 100vw; transition: filter 0.8s ease; }
        body.dark-mode #map { filter: brightness(0.6) grayscale(0.2); }

        /* æœç´¢æ¡†ä¸è‡ªåŠ¨è¡¥å…¨ */
        .top-bar { position: absolute; top: 15px; width: 90%; left: 5%; z-index: 1000; display: flex; gap: 10px; }
        #destInput { flex: 1; padding: 12px 20px; border-radius: 25px; border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.15); font-size: 16px; background: var(--panel); color: var(--text); }
        .theme-btn { background: var(--panel); border: none; width: 45px; height: 45px; border-radius: 50%; cursor: pointer; font-size: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); }

        /* åº•éƒ¨è·¯å¾„åŒºåŸŸ */
        .bottom-nav { position: fixed; bottom: 0; width: 100%; height: 40vh; background: var(--panel); color: var(--text); display: flex; flex-direction: column; border-top: 1px solid rgba(0,0,0,0.1); z-index: 1001; }
        .nav-tabs { display: flex; height: 100%; }
        .nav-card { flex: 1; padding: 15px 10px; border-right: 1px solid rgba(0,0,0,0.05); display: flex; flex-direction: column; cursor: pointer; transition: 0.3s; }
        .nav-card.active { background: rgba(128, 0, 0, 0.08); border-top: 3px solid var(--accent); }
        .nav-card h4 { margin: 0 0 8px 0; font-size: 14px; color: var(--accent); }
        .nav-card .desc { font-size: 11px; line-height: 1.5; color: #666; overflow-y: auto; flex-grow: 1; }
        body.dark-mode .nav-card .desc { color: #bbb; }

        /* å¼¹çª—æ ·å¼ */
        .custom-popup .leaflet-popup-content-wrapper { background: var(--panel); color: var(--text); border-radius: 12px; }
        .nav-btn { background: var(--accent); color: white; border: none; padding: 8px 15px; border-radius: 5px; margin-top: 10px; cursor: pointer; width: 100%; }
    </style>
</head>
<body>

<div class="top-bar">
    <input type="text" id="destInput" list="pointsList" placeholder="æœç´¢æ·±å¤§åœ°ç‚¹..." oninput="checkInput(this.value)">
    <datalist id="pointsList"></datalist>
    <button class="theme-btn" onclick="toggleTheme()">ğŸŒ“</button>
</div>

<div id="map"></div>

<div class="bottom-nav">
    <div class="nav-tabs">
        <div class="nav-card" id="card-best" onclick="displayRoute('best')">
            <h4 id="h-best">èˆ’é€‚æœ€ä¼˜</h4>
            <div class="desc" id="d-best">ç‚¹å‡»åœ°å›¾ä¸Šçš„ç‚¹æˆ–æœç´¢å¼€å§‹å¯¼èˆª</div>
        </div>
        <div class="nav-card" id="card-alt1" onclick="displayRoute('alt1')">
            <h4 id="h-alt1">å¤‡é€‰ï¼šæœ€çŸ­</h4>
            <div class="desc" id="d-alt1">â€”â€”</div>
        </div>
        <div class="nav-card" id="card-alt2" onclick="displayRoute('alt2')">
            <h4 id="h-alt2">å¤‡é€‰ï¼šå®‰å…¨</h4>
            <div class="desc" id="d-alt2">â€”â€”</div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/geojson-path-finder/dist/geojson-path-finder.min.js"></script>

<script>
    // 1. åˆå§‹åŒ–åœ°å›¾ä¸æ·±å¤§èŒƒå›´é™åˆ¶
    const szuBounds = [[22.518, 113.925], [22.545, 113.945]];
    const map = L.map('map', { maxBounds: szuBounds, minZoom: 15 }).setView([22.533, 113.935], 16);
    L.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png').addTo(map);

    let isNight = false, roadsData, pointsData, userLocation, finder;
    let routes = { best: null, alt1: null, alt2: null };
    let currentLayers = [];

    // 2. åŠ è½½æ•°æ®å¹¶åˆå§‹åŒ–
    Promise.all([
        fetch('roads.json').then(r => r.json()),
        fetch('points.json').then(r => r.json())
    ]).then(([roads, points]) => {
        roadsData = roads;
        pointsData = points;
        
        // æ¸²æŸ“æ‰€æœ‰ç‚¹å¹¶å¡«å……æœç´¢æç¤º
        const list = document.getElementById('pointsList');
        L.geoJSON(points, {
            pointToLayer: (f, l) => {
                const opt = document.createElement('option');
                opt.value = f.properties.name;
                list.appendChild(opt);
                return L.marker(l);
            },
            onEachFeature: (f, layer) => {
                const content = `<b>${f.properties.name}</b><br><button class="nav-btn" onclick="startNavigation('${f.properties.name}')">åˆ°è¿™é‡Œå»</button>`;
                layer.bindPopup(content, { className: 'custom-popup' });
            }
        }).addTo(map);
    });

    // 3. å®æ—¶å®šä½
    map.on('locationfound', e => {
        userLocation = e.latlng;
        L.circleMarker(e.latlng, {radius: 6, color: '#800000', fillOpacity: 1}).addTo(map);
    });
    map.locate({setView: true, watch: true});

    // 4. ä¸»é¢˜åˆ‡æ¢
    function toggleTheme() {
        isNight = !isNight;
        document.body.classList.toggle('dark-mode');
        document.getElementById('h-best').innerText = isNight ? "æ›´å®‰å…¨(æœ€ä¼˜)" : "èˆ’é€‚æœ€ä¼˜";
        if(routes.best) startNavigation(document.getElementById('destInput').value);
    }

    // 5. æœç´¢æ¡†åŒ¹é…æ£€æŸ¥
    function checkInput(val) {
        const found = pointsData.features.some(f => f.properties.name === val);
        if(found) startNavigation(val);
    }

    // 6. æ ¸å¿ƒå¯¼èˆªè§¦å‘é€»è¾‘
    async function startNavigation(name) {
        document.getElementById('destInput').value = name;
        const target = pointsData.features.find(f => f.properties.name === name);
        if(!target || !userLocation) return;

        map.closePopup();

        // è®¡ç®—ä¸‰æ¡è·¯å¾„
        routes.best = calculatePath('best', target.geometry.coordinates);
        routes.alt1 = calculatePath('alt1', target.geometry.coordinates, routes.best?.edgeIds);
        routes.alt2 = calculatePath('alt2', target.geometry.coordinates, [...(routes.best?.edgeIds||[]), ...(routes.alt1?.edgeIds||[])]);

        updateUI();
        displayRoute('best'); // é»˜è®¤æ˜¾ç¤ºæœ€ä¼˜
    }

    function calculatePath(type, destCoords, penaltyIds = []) {
        // åŠ¨æ€æƒé‡ç®—æ³• (åŒ…å«é’ˆå¯¹ length çš„å†²çªè°ƒæ•´)
        let lBoost = 0;
        let result = null;
        
        const compute = (boost) => {
            const pFinder = new geojsonPathFinder(roadsData, {
                weightFn: (a, b, props) => {
                    const { length: L, width: W, env: E, safe: S } = props;
                    const penalty = penaltyIds.includes(props.id) ? 100 : 1;
                    let w = 0;
                    if(!isNight){ // ç™½å¤©
                        if(type === 'best') w = (L*0.2 + W*0.2 + E*0.4 + S*0.2);
                        if(type === 'alt1') w = ((L+boost)*0.5 + W*0.2 + E*0.3);
                        if(type === 'alt2') w = ((L+boost)*0.3 + W*0.3 + S*0.4);
                    } else { // é»‘å¤œ
                        if(type === 'best') w = (L*0.2 + W*0.2 + E*0.2 + S*0.4);
                        if(type === 'alt1') w = ((L+boost)*0.5 + W*0.2 + S*0.3);
                        if(type === 'alt2') w = ((L+boost)*0.2 + W*0.2 + S*0.2 + E*0.4);
                    }
                    return w * penalty;
                }
            });
            return pFinder.findPath({geometry:{coordinates:[userLocation.lng, userLocation.lat]}}, {geometry:{coordinates:destCoords}});
        };

        result = compute(0);
        // å¦‚æœæ˜¯å¤‡é€‰ä¸”é‡å¤ï¼Œè°ƒæ•´ length æƒé‡é‡æ–°ç®—
        if(type !== 'best' && penaltyIds.length > 0 && result) {
            let retry = 0;
            while(retry < 3 && result.edgeIds?.some(id => penaltyIds.includes(id))) {
                lBoost += 0.5;
                result = compute(lBoost);
                retry++;
            }
        }
        return result;
    }

    function displayRoute(type) {
        currentLayers.forEach(l => map.removeLayer(l));
        currentLayers = [];
        
        document.querySelectorAll('.nav-card').forEach(c => c.classList.remove('active'));
        document.getElementById('card-' + type).classList.add('active');

        const r = routes[type];
        if(r) {
            const color = type === 'best' ? '#800000' : (type === 'alt1' ? '#007AFF' : '#34C759');
            const poly = L.polyline(r.path.map(p => [p[1], p[0]]), {color, weight: 7, opacity: 0.8}).addTo(map);
            currentLayers.push(poly);
            map.fitBounds(poly.getBounds(), {padding: [50, 50]});
        }
    }

    function updateUI() {
        const labels = {
            best: isNight ? "é»‘å¤œå®‰å…¨ä¼˜å…ˆï¼Œé¿å¼€æš—å¤„" : "ç™½å¤©èˆ’é€‚ä¼˜å…ˆï¼Œé£æ™¯è¾ƒå¥½",
            alt1: "è·ç¦»æœ€çŸ­æ–¹æ¡ˆï¼Œå¯èƒ½ç»è¿‡çª„è·¯",
            alt2: isNight ? "ç¯å¢ƒæ›´ä¼˜ï¼Œç¯å…‰è¾ƒå¥½" : "å®‰å…¨ç­‰çº§æœ€é«˜è·¯æ®µ"
        };
        ['best', 'alt1', 'alt2'].forEach(t => {
            const r = routes[t];
            document.getElementById('d-'+t).innerHTML = r ? 
                `<b>${labels[t]}</b><br>é¢„è®¡è·¯ç¨‹: ${(r.weight*100).toFixed(0)}ç±³<br>è·¯æ®µæ•°: ${r.path.length}` : "æ— æ³•è§„åˆ’æ­¤è·¯çº¿";
        });
    }
</script>
</body>
</html>